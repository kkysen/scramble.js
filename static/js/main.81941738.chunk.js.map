{"version":3,"sources":["main/board.tsx","main/range.ts","main/shuffle.ts","main/lexicon.ts","main/lexicons.ts","main/globals.ts","main/lexiconIndex.ts","main/game.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Letter","letter","selected","setSelected","isWord","boardSize","size","a","scale","n","onClick","style","backgroundColor","padding","margin","width","fontSize","borderWidth","borderStyle","borderRadius","textAlign","Word","word","selectedIndex","setSelectedIndex","display","justifyContent","alignItems","alignContent","fontWeight","toUpperCase","map","i","Board","words","solution","shuffled","check","wordChecker","Solution","console","log","initState","useCallback","x","y","solved","useState","setState","useEffect","j","splitWords","temp","newWords","join","setIJ","length","showSolution","range_iter","start","stop","step","range","iterate","shuffle","Math","floor","random","LexiconMetadataImpl","metadata","this","name","numWords","fileSize","numBytes","Lexicon","handle","rawWordsByLength","filter","s","toLowerCase","toSet","wordsByLength","e","reduce","max","toArray","push","maxLengthBound","lengthRange","hasLength","find","has","every","checkWord","checkWords","Error","randomWord","randomWords","letters","shuffledString","end","slice","LexiconHandleImpl","lexicon","undefined","fetch","response","text","startsWith","split","Promise","lexiconPromise","then","Symbol","iterator","obj","lexicons","metadatas","handles","defaultNameKey","_defaultName","toMap","getDefaultName","default","get","values","defaultName","localStorage","getItem","iter","setItem","names","Object","assign","globalThis","GameSolution","Game","randomShuffledWords","NewGameChooser","options","setOptions","starting","again","lexiconHandle","setLexiconHandle","getCached","setLexicon","setSize","newLexicon","updateDefault","disabled","value","label","onChange","consecutiveLengths","toString","parseInt","Games","App","className","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.81941738.chunk.js","sourcesContent":["import {FC, useCallback, useEffect, useState} from \"react\";\nimport {ShuffledWords, WordChecker} from \"./lexicon\";\n\nconst Letter: FC<{\n    letter: string;\n    selected: boolean;\n    setSelected: () => void;\n    isWord: boolean;\n    boardSize: number;\n}> = ({letter, selected, setSelected, isWord, boardSize}) => {\n    const size = ((): (n: number) => number => {\n        // we want to pin these two scales and adjust in-between\n        // use point-slope form to calculate scale\n        interface Point {\n            readonly boardSize: number;\n            readonly scale: number;\n        }\n        const a: Point = {boardSize: 5, scale: 1}\n        const b: Point = {boardSize: 25, scale: 2}\n        const slope = (a.scale - b.scale) / (a.boardSize - b.boardSize);\n        const scale = slope * (boardSize - a.boardSize) + a.scale;\n        return n => n / scale;\n    })();\n    \n    return <div\n        onClick={setSelected}\n        style={{\n            backgroundColor: selected ? \"yellow\" : \"white\",\n            padding: `${size(1)}%`,\n            margin: `${size(0.2)}%`,\n            width: `${size(3)}%`,\n            fontSize: `${size(3)}vw`,\n            borderWidth: `${size(1)}vw`,\n            borderStyle: selected ? \"inset\" : \"outset\",\n            borderRadius: isWord ? `${size(2)}vw` : 0,\n            textAlign: \"center\",\n        }}\n    >\n        {letter}\n    </div>;\n};\n\nconst Word: FC<{\n    word: string;\n    isWord: boolean;\n    selectedIndex: number;\n    setSelectedIndex: (index: number) => void;\n    boardSize: number;\n}> = ({word, isWord, selectedIndex, setSelectedIndex, boardSize}) => {\n    return <div style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        alignContent: \"center\",\n        fontWeight: isWord ? \"bold\" : \"normal\",\n    }}>\n        {[...word.toUpperCase()].map((letter, i) => <Letter\n            key={i}\n            letter={letter}\n            selected={selectedIndex === i}\n            setSelected={() => setSelectedIndex(i)}\n            isWord={isWord}\n            boardSize={boardSize}\n        />)}\n    </div>;\n};\n\nexport interface SolutionProps {\n    solved: boolean;\n    showSolution: () => void;\n}\n\nexport const Board: FC<{\n    words: ShuffledWords;\n    wordChecker: WordChecker;\n    Solution: FC<SolutionProps>;\n}> = ({words: {solution, shuffled}, wordChecker: check, Solution}) => {\n    console.log(solution);\n    \n    const initState = useCallback(() => {\n        return {x: -1, y: -1, words: shuffled, solved: check.words(shuffled)};\n    }, [check, shuffled]);\n    \n    const [{x, y, words, solved}, setState] = useState(initState);\n    \n    useEffect(() => {\n        setState(initState());\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [initState]);\n    \n    function setIJ(i: number, j: number) {\n        if (y === -1 || x === -1) {\n            // no letters clicked on yet\n            setState({x: i, y: j, words, solved});\n        } else if (x === i && y === j) {\n            // clicked on same letter twice\n            setState({x: -1, y: -1, words, solved});\n        } else {\n            // one letter clicked on, so swap them now\n            const splitWords = words.map(word => [...word]);\n            const temp = splitWords[i][j];\n            splitWords[i][j] = splitWords[x][y];\n            splitWords[x][y] = temp;\n            const newWords = splitWords.map(word => word.join(\"\"));\n            setState({x: -1, y: -1, words: newWords, solved: check.words(newWords)});\n        }\n    }\n    \n    return <>\n        <div>\n            {words.map((word, i) => <Word\n                key={i}\n                word={word}\n                isWord={check.word(word)}\n                selectedIndex={i === x ? y : -1}\n                setSelectedIndex={j => setIJ(i, j)}\n                boardSize={words.length}\n            />)}\n        </div>\n        <Solution\n            solved={solved}\n            showSolution={() => setState({x: -1, y: -1, words: solution, solved: true})}\n        />\n    </>;\n};\n","import iterate from \"iterare\";\nimport {IteratorWithOperators} from \"iterare/lib/iterate\";\n\nexport interface Range {\n    start?: number;\n    stop: number;\n    step?: number;\n}\n\nfunction* range_iter({start = 0, stop, step = 1}: Range) {\n    while (start < stop) {\n        yield start;\n        start += step;\n    }\n}\n\nexport function range(range: Range): IteratorWithOperators<number> {\n    return iterate(range_iter(range));\n}\n","export function shuffle<T>(a: T[]) {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * i);\n        const temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n}\n\nexport function shuffled<T>(a: readonly T[]): T[] {\n    const b = [...a];\n    shuffle(b);\n    return b;\n}\n\nexport function shuffledString(s: string): string {\n    const a = [...s];\n    shuffle(a);\n    return a.join(\"\");\n}\n","import fileSize from \"filesize\";\nimport iterate from \"iterare\";\nimport {IteratorWithOperators} from \"iterare/lib/iterate\";\nimport {LexiconHandle} from \"./lexicons\";\nimport {range} from \"./range\";\nimport {shuffledString} from \"./shuffle\";\n\nexport interface LexiconSize {\n    readonly numWords: number;\n    readonly numChars: number;\n    readonly numBytes: number;\n}\n\nexport interface LexiconMetadata {\n    readonly name: string;\n    readonly size: LexiconSize;\n}\n\nexport interface LexiconMetadataPlus extends LexiconMetadata {\n    toString(): string;\n    label(): string;\n}\n\nexport class LexiconMetadataImpl implements LexiconMetadataPlus {\n    \n    constructor(protected metadata: LexiconMetadata) {}\n    \n    get name(): string {\n        return this.metadata.name;\n    }\n    \n    get size(): LexiconSize {\n        return this.metadata.size;\n    }\n    \n    toString(): string {\n        return `Lexicon ${this.name}`;\n    }\n    \n    label(): string {\n        return `${this.name} (${this.size.numWords} words, ${fileSize(this.size.numBytes)})`;\n    }\n    \n}\n\nexport class Lexicon extends LexiconMetadataImpl {\n    readonly handle: LexiconHandle;\n    private readonly words: ReadonlySet<string>;\n    private readonly rawWordsByLength: readonly ReadonlyArray<string>[];\n    \n    constructor(handle: LexiconHandle, words: Iterable<string>) {\n        super(handle);\n        this.handle = handle;\n        this.words = iterate(words)\n            .filter(s => s.length > 0)\n            .map(s => s.toLowerCase())\n            .toSet();\n        const maxLength = iterate(this.words).map(e => e.length).reduce(Math.max);\n        const wordsByLength: string[][] = range({stop: maxLength + 1})\n            .map(() => [] as string[])\n            .toArray();\n        for (const word of this.words) {\n            wordsByLength[word.length].push(word);\n        }\n        this.rawWordsByLength = wordsByLength;\n    }\n    \n    toString(): string {\n        return `${this.name} Lexicon (${this.words.size} words)`;\n    }\n    \n    private wordsByLength(length: number): readonly string[] {\n        return this.rawWordsByLength[length] ?? [];\n    }\n    \n    hasLength(length: number): boolean {\n        return this.wordsByLength(length).length > 0;\n    }\n    \n    private maxLengthBound(): number {\n        return this.rawWordsByLength.length;\n    }\n    \n    private lengthRange(): IteratorWithOperators<number> {\n        return range({start: 1, stop: this.maxLengthBound()});\n    }\n    \n    lengths(): IteratorWithOperators<number> {\n        return this\n            .lengthRange()\n            .filter(length => this.hasLength(length));\n    }\n    \n    consecutiveLengths(): IteratorWithOperators<number> {\n        const onePastMaxLength = this\n                .lengthRange()\n                .find(length => !this.hasLength(length))\n            ?? this.maxLengthBound();\n        return range({start: 1, stop: onePastMaxLength});\n    }\n    \n    checkWord(word: string): boolean {\n        return this.words.has(word);\n    }\n    \n    checkWords(words: readonly string[]): boolean {\n        return words.every(word => this.checkWord(word));\n    }\n    \n    wordChecker(): WordChecker {\n        return {\n            word: word => this.checkWord(word),\n            words: words => this.checkWords(words),\n        };\n    }\n    \n    randomWord(length: number): string {\n        if (!this.hasLength(length)) {\n            throw new Error(`${this} has no words of length ${length}`);\n        }\n        const words = this.wordsByLength(length);\n        return words[(Math.random() * words.length) | 0];\n    }\n    \n    randomWords(size: number): IteratorWithOperators<string> {\n        return range({stop: size})\n            .map(i => this.randomWord(i + 1));\n    }\n    \n    randomShuffledWords(size: number): ShuffledWords {\n        const solution = this.randomWords(size).toArray();\n        const letters = shuffledString(solution.join(\"\"));\n        const words: string[] = [];\n        let start = 0;\n        for (let i = 1; i <= size; i++) {\n            const end = start + i;\n            words.push(letters.slice(start, end));\n            start = end;\n        }\n        return {solution, shuffled: words};\n    }\n    \n}\n\nexport interface ShuffledWords {\n    readonly solution: readonly string[];\n    readonly shuffled: readonly string[];\n}\n\nexport interface WordChecker {\n    \n    word(word: string): boolean;\n    \n    words(words: readonly string[]): boolean;\n    \n}\n","import iterate from \"iterare\";\nimport {IteratorWithOperators} from \"iterare/lib/iterate\";\nimport {globals} from \"./globals\";\nimport {Lexicon, LexiconMetadata, LexiconMetadataImpl, LexiconMetadataPlus} from \"./lexicon\";\nimport {lexiconIndex} from \"./lexiconIndex\";\nimport {MaybePromise} from \"./maybePromise\";\n\nexport interface LexiconHandle extends LexiconMetadataPlus {\n    getCachedPromise(): MaybePromise<Lexicon> | undefined;\n    \n    getCached(): Lexicon | undefined;\n    \n    get(): MaybePromise<Lexicon>;\n}\n\nclass LexiconHandleImpl extends LexiconMetadataImpl implements LexiconHandle {\n    \n    private lexicon: MaybePromise<Lexicon> | undefined = undefined;\n    \n    private async fetch(): Promise<Lexicon> {\n        const name = this.name;\n        const response = await fetch(`/lexicons/${name}.txt`);\n        const text = await response.text();\n        if (text.startsWith(\"<!DOCTYPE html>\")) {\n            throw new Error(`the ${this} doesn't actually exist on the server`);\n        }\n        return new Lexicon(this, text.split(\"\\n\"));\n    }\n    \n    getCachedPromise(): MaybePromise<Lexicon> | undefined {\n        return this.lexicon;\n    }\n    \n    getCached(): Lexicon | undefined {\n        if (this.lexicon instanceof Promise) {\n            return;\n        }\n        return this.lexicon;\n    }\n    \n    get(): MaybePromise<Lexicon> {\n        if (this.lexicon) {\n            return this.lexicon;\n        }\n        const lexiconPromise = this.fetch();\n        this.lexicon = lexiconPromise;\n        lexiconPromise.then(lexicon => this.lexicon = lexicon);\n        return lexiconPromise;\n    }\n    \n}\n\nclass Lexicons {\n    \n    private readonly handles: Map<string, LexiconHandle>;\n    private readonly defaultNameKey: string;\n    private _defaultName: string;\n    \n    constructor(metadatas: readonly LexiconMetadata[]) {\n        this.handles = iterate(metadatas)\n            .map(metadata => [metadata.name, new LexiconHandleImpl(metadata)] as [string, LexiconHandle])\n            .toMap();\n        this.defaultNameKey = \"scramble.lexicon.default\";\n        this._defaultName = this.getDefaultName();\n        this.default().get(); // fetch immediately\n    }\n    \n    [Symbol.iterator](): IterableIterator<LexiconHandle> {\n        return this.handles.values();\n    }\n    \n    iter(): IteratorWithOperators<LexiconHandle> {\n        return iterate(this);\n    }\n    \n    private getDefaultName(): string {\n        // store default in localStorage so you resume with the previous default\n        // use localStorage since it's synchronous, so don't need to use async-await here\n        // since the data I'm storing is so small, just a name, that shouldn't be a problem at all\n        const defaultName = localStorage.getItem(this.defaultNameKey);\n        if (defaultName !== null && this.handles.has(defaultName)) {\n            return defaultName;\n        } else {\n            return this.iter().map(e => e.name).find(() => true)!;\n        }\n    }\n    \n    updateDefault(metadata: LexiconMetadata) {\n        this._defaultName = metadata.name;\n        localStorage.setItem(this.defaultNameKey, this._defaultName);\n    }\n    \n    get(name: string): LexiconHandle {\n        const handle = this.handles.get(name);\n        if (!handle) {\n            const names = this.iter().map(e => e.name);\n            throw new Error(`the Lexicon ${name} doesn't exist in {${names.join(\", \")}}`);\n        }\n        return handle;\n    }\n    \n    default(): LexiconHandle {\n        return this.get(this._defaultName);\n    }\n    \n}\n\n// see indexLexicons.mjs\nexport const lexicons = new Lexicons(lexiconIndex);\n\nglobals({lexicons});\n","export function globals(obj: object) {\n    Object.assign(globalThis, obj);\n}\n","// see indexLexicons.mjs\n\nimport {LexiconMetadata} from \"./lexicon\";\n\nexport const lexiconIndex: readonly LexiconMetadata[] = [\n    {\n        \"name\": \"English Sample\",\n        \"size\": {\n            \"numWords\": 16,\n            \"numChars\": 47,\n            \"numBytes\": 62\n        }\n    },\n    {\n        \"name\": \"English\",\n        \"size\": {\n            \"numWords\": 410323,\n            \"numChars\": 3802737,\n            \"numBytes\": 4213059\n        }\n    },\n    {\n        \"name\": \"Spanish\",\n        \"size\": {\n            \"numWords\": 2,\n            \"numChars\": 7,\n            \"numBytes\": 8\n        }\n    }\n];","import {FC, useEffect, useState} from \"react\";\nimport {default as Dropdown} from \"react-dropdown\";\nimport \"react-dropdown/style.css\";\nimport {Board, SolutionProps} from \"./board\";\nimport {Lexicon} from \"./lexicon\";\nimport {LexiconHandle, lexicons} from \"./lexicons\";\n\ninterface GameOptions {\n    lexicon: Lexicon;\n    size: number;\n}\n\nconst GameSolution: FC<SolutionProps> = ({solved, showSolution}) => <div>\n    {solved ? \"Done!\" : <button onClick={showSolution}>Show Solution</button>}\n</div>;\n\nexport const Game: FC<GameOptions> = ({lexicon, size}) => {\n    const words = lexicon.randomShuffledWords(size);\n    console.log(words.solution);\n    return <div>\n        <Board\n            words={words}\n            wordChecker={lexicon.wordChecker()}\n            Solution={GameSolution}\n        />\n    </div>;\n};\n\ninterface StartGameOptions {\n    readonly again: boolean;\n    readonly lexiconHandle: LexiconHandle;\n    readonly size?: number;\n}\n\nconst NewGameChooser: FC<{\n    options?: GameOptions,\n    setOptions: (options: GameOptions) => void,\n}> = ({options, setOptions}) => {\n    const starting = ((): StartGameOptions => {\n        if (options) {\n            return {\n                again: true,\n                ...options,\n                lexiconHandle: options.lexicon.handle,\n            };\n        } else {\n            return {\n                again: false,\n                lexiconHandle: lexicons.default(),\n            };\n        }\n    })();\n    \n    const [lexiconHandle, setLexiconHandle] = useState(starting.lexiconHandle);\n    const [lexicon, setLexicon] = useState(starting.lexiconHandle.getCached());\n    const [size, setSize] = useState(starting.size);\n    \n    useEffect(() => {\n        // so that an old chosen size doesn't go chosen with a wrong lexicon\n        setSize(undefined);\n        \n        const newLexicon = lexiconHandle.get();\n        if (newLexicon instanceof Promise) {\n            newLexicon.then(setLexicon);\n        } else {\n            setLexicon(newLexicon);\n        }\n    }, [lexiconHandle]);\n    \n    useEffect(() => {\n        if (lexicon) {\n            lexicons.updateDefault(lexicon);\n        }\n    }, [lexicon]);\n    \n    return <div>\n        <button\n            disabled={!(lexicon && size !== undefined)}\n            onClick={() => {\n                if (lexicon && size !== undefined) {\n                    setOptions({lexicon, size});\n                } else {\n                    throw new Error(`impossible`);\n                }\n            }}>\n            {`Play${starting.again ? \" Again\" : \"\"}!`}\n        </button>\n        <br/>\n        <label>Lexicon</label>\n        <Dropdown\n            options={lexicons.iter().map(e => ({value: e.name, label: e.label()})).toArray()}\n            value={lexiconHandle.name}\n            onChange={e => setLexiconHandle(lexicons.get(e.value))}\n        />\n        {lexicon && <>\n            <label>Size</label>\n            <Dropdown\n                options={lexicon.consecutiveLengths().map(e => e.toString()).toArray()}\n                value={size?.toString()}\n                onChange={e => setSize(parseInt(e.value))}\n            />\n        </>}\n    </div>;\n};\n\nexport const Games: FC = () => {\n    const [options, setOptions] = useState<GameOptions | undefined>();\n    return <div>\n        {options && <Game lexicon={options.lexicon} size={options.size}/>}\n        <NewGameChooser options={options} setOptions={setOptions}/>\n    </div>;\n};\n","import \"./App.css\";\nimport {Games} from \"./main/game\";\n\nfunction App() {\n    return <div className=\"App\">\n        <Games/>\n    </div>;\n}\n\nexport default App;\n","import {ReportHandler} from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n    if (onPerfEntry && onPerfEntry instanceof Function) {\n        import(\"web-vitals\").then(({getCLS, getFID, getFCP, getLCP, getTTFB}) => {\n            getCLS(onPerfEntry);\n            getFID(onPerfEntry);\n            getFCP(onPerfEntry);\n            getLCP(onPerfEntry);\n            getTTFB(onPerfEntry);\n        });\n    }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"./index.css\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n    <React.StrictMode>\n        <App/>\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}