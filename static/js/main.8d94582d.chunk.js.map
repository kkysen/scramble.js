{"version":3,"sources":["main/board.tsx","main/range.ts","main/shuffle.ts","main/lexicon.ts","main/lexicons.ts","main/globals.ts","main/lexiconIndex.ts","main/game.tsx","reportWebVitals.ts","main/instructions.tsx","main/scramble.tsx","App.tsx","index.tsx"],"names":["Letter","letter","selected","setSelected","isWord","boardSize","size","a","scale","n","onClick","style","backgroundColor","color","padding","margin","width","fontSize","borderWidth","borderStyle","borderRadius","textAlign","Word","word","selectedIndex","setSelectedIndex","display","justifyContent","alignItems","alignContent","fontWeight","toUpperCase","map","i","Board","shuffleWords","words","check","wordChecker","Solution","solution","shuffled","initState","useCallback","isFirst","x","y","solved","numMoves","useState","setState","showingSolution","setWords","args","move","useEffect","console","log","join","j","splitWords","temp","setIJ","length","showSolution","shuffle","range_iter","start","stop","step","range","iterate","Math","floor","random","LexiconMetadataImpl","metadata","this","name","numWords","fileSize","numBytes","Lexicon","handle","rawWordsByLength","filter","s","toLowerCase","toSet","wordsByLength","e","reduce","max","toArray","push","maxLengthBound","lengthRange","hasLength","find","has","every","checkWord","checkWords","Error","randomWord","ShuffledWords","randomWords","_shuffled","letters","shuffledString","end","slice","doShuffle","LexiconHandleImpl","lexicon","undefined","fetch","url","response","text","startsWith","split","Promise","lexiconPromise","then","process","Symbol","iterator","obj","lexicons","metadatas","handles","defaultNameKey","_defaultName","toMap","getDefaultName","default","get","values","defaultName","localStorage","getItem","iter","setItem","names","Object","assign","globalThis","onPerfEntry","GameSolution","Game","randomShuffledWords","NewGameChooser","options","setOptions","starting","again","lexiconHandle","setLexiconHandle","getCached","setLexicon","setSize","newLexicon","updateDefault","disabled","value","label","onChange","consecutiveLengths","toString","parseInt","Games","Instructions","marginLeft","marginRight","minWidth","Scramble","App","ReactDOM","render","StrictMode","document","querySelector","Function","getCLS","getFID","getFCP","getLCP","getTTFB"],"mappings":"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","file":"static/js/main.8d94582d.chunk.js","sourcesContent":["import {FC, useCallback, useEffect, useState} from \"react\";\nimport {ShuffledWords, WordChecker} from \"./lexicon\";\n\nconst Letter: FC<{\n    letter: string;\n    selected: boolean;\n    setSelected: () => void;\n    isWord: boolean;\n    boardSize: number;\n}> = ({letter, selected, setSelected, isWord, boardSize}) => {\n    const size = ((): (n: number) => number => {\n        // we want to pin these two scales and adjust in-between\n        // use point-slope form to calculate scale\n        interface Point {\n            readonly boardSize: number;\n            readonly scale: number;\n        }\n        \n        const a: Point = {boardSize: 5, scale: 1};\n        const b: Point = {boardSize: 25, scale: 2};\n        const slope = (a.scale - b.scale) / (a.boardSize - b.boardSize);\n        const scale = slope * (boardSize - a.boardSize) + a.scale;\n        return n => (n / scale) * 1.5;\n    })();\n    \n    return <div\n        onClick={setSelected}\n        style={{\n            backgroundColor: selected ? \"yellow\" : isWord ? \"#13E049\" : \"white\",\n            color: selected ? \"black\" : isWord ? \"red\" : \"black\",\n            padding: `${size(1)}%`,\n            margin: `${size(0.2)}%`,\n            width: `${size(3)}%`,\n            fontSize: `${size(3)}vw`,\n            borderWidth: `${size(1)}vw`,\n            borderStyle: selected ? \"inset\" : \"outset\",\n            borderRadius: isWord ? `${size(2)}vw` : 0,\n            textAlign: \"center\",\n        }}\n    >\n        {letter}\n    </div>;\n};\n\nconst Word: FC<{\n    word: string;\n    isWord: boolean;\n    selectedIndex: number;\n    setSelectedIndex: (index: number) => void;\n    boardSize: number;\n}> = ({word, isWord, selectedIndex, setSelectedIndex, boardSize}) => {\n    return <div style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        alignContent: \"center\",\n        fontWeight: isWord ? \"bold\" : \"normal\",\n    }}>\n        {[...word.toUpperCase()].map((letter, i) => <Letter\n            key={i}\n            letter={letter}\n            selected={selectedIndex === i}\n            setSelected={() => setSelectedIndex(i)}\n            isWord={isWord}\n            boardSize={boardSize}\n        />)}\n    </div>;\n};\n\nexport interface SolutionProps {\n    solved: boolean;\n    showingSolution: boolean;\n    showSolution: () => void;\n    numMoves: number;\n    shuffle: () => void;\n}\n\nexport const Board: FC<{\n    words: ShuffledWords;\n    wordChecker: WordChecker;\n    Solution: FC<SolutionProps>;\n}> = ({words: shuffleWords, wordChecker: check, Solution}) => {\n    const {solution, shuffled} = shuffleWords;\n    \n    const initState = useCallback((isFirst: boolean) => {\n        return {isFirst, x: -1, y: -1, words: shuffled, solved: check.words(shuffled), numMoves: 0};\n    }, [check, shuffled]);\n    \n    const [{isFirst, x, y, words, solved, numMoves}, setState] = useState(initState(true));\n    const showingSolution = words === solution;\n    \n    function setWords(args: {words: readonly string[]; move: boolean, solved?: boolean}) {\n        setState({\n            isFirst: false,\n            x: -1,\n            y: -1,\n            words: args.words,\n            solved: args.solved ?? check.words(args.words),\n            numMoves: numMoves + (args.move ? 1 : 0),\n        });\n    }\n    \n    useEffect(() => {\n        if (!isFirst) {\n            console.log(solution.join(\"\\n\"));\n        }\n    }, [isFirst, solution])\n    \n    useEffect(() => {\n        setState(initState(false));\n    }, [initState]);\n    \n    function setIJ(i: number, j: number) {\n        if (y === -1 || x === -1) {\n            // no letters clicked on yet\n            setState({isFirst: false, x: i, y: j, words, solved, numMoves});\n        } else if (x === i && y === j) {\n            // clicked on same letter twice\n            setWords({words, move: false, solved});\n        } else {\n            // one letter clicked on, so swap them now\n            const splitWords = words.map(word => [...word]);\n            const temp = splitWords[i][j];\n            splitWords[i][j] = splitWords[x][y];\n            splitWords[x][y] = temp;\n            setWords({words: splitWords.map(word => word.join(\"\")), move: true});\n        }\n    }\n    \n    return <>\n        <div>\n            {words.map((word, i) => <Word\n                key={i}\n                word={word}\n                isWord={check.word(word)}\n                selectedIndex={i === x ? y : -1}\n                setSelectedIndex={j => setIJ(i, j)}\n                boardSize={words.length}\n            />)}\n        </div>\n        <Solution\n            solved={solved}\n            showingSolution={showingSolution}\n            showSolution={() => setWords({words: solution, move: false, solved: true})}\n            numMoves={numMoves}\n            shuffle={() => setWords({words: shuffleWords.shuffle(), move: false})}\n        />\n    </>;\n};\n","import iterate from \"iterare\";\nimport {IteratorWithOperators} from \"iterare/lib/iterate\";\n\nexport interface Range {\n    start?: number;\n    stop: number;\n    step?: number;\n}\n\nfunction* range_iter({start = 0, stop, step = 1}: Range) {\n    while (start < stop) {\n        yield start;\n        start += step;\n    }\n}\n\nexport function range(range: Range): IteratorWithOperators<number> {\n    return iterate(range_iter(range));\n}\n","export function shuffle<T>(a: T[]) {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * i);\n        const temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n}\n\nexport function shuffled<T>(a: readonly T[]): T[] {\n    const b = [...a];\n    shuffle(b);\n    return b;\n}\n\nexport function shuffledString(s: string): string {\n    const a = [...s];\n    shuffle(a);\n    return a.join(\"\");\n}\n","import fileSize from \"filesize\";\nimport iterate from \"iterare\";\nimport {IteratorWithOperators} from \"iterare/lib/iterate\";\nimport {LexiconHandle} from \"./lexicons\";\nimport {range} from \"./range\";\nimport {shuffledString} from \"./shuffle\";\n\nexport interface LexiconSize {\n    readonly numWords: number;\n    readonly numChars: number;\n    readonly numBytes: number;\n}\n\nexport interface LexiconMetadata {\n    readonly name: string;\n    readonly size: LexiconSize;\n}\n\nexport interface LexiconMetadataPlus extends LexiconMetadata {\n    toString(): string;\n    \n    label(): string;\n}\n\nexport class LexiconMetadataImpl implements LexiconMetadataPlus {\n    \n    constructor(protected metadata: LexiconMetadata) {}\n    \n    get name(): string {\n        return this.metadata.name;\n    }\n    \n    get size(): LexiconSize {\n        return this.metadata.size;\n    }\n    \n    toString(): string {\n        return `Lexicon \"${this.name}\"`;\n    }\n    \n    label(): string {\n        return `${this.name} (${this.size.numWords} words, ${fileSize(this.size.numBytes)})`;\n    }\n    \n}\n\nexport class Lexicon extends LexiconMetadataImpl {\n    readonly handle: LexiconHandle;\n    private readonly words: ReadonlySet<string>;\n    private readonly rawWordsByLength: readonly ReadonlyArray<string>[];\n    \n    constructor(handle: LexiconHandle, words: Iterable<string>) {\n        super(handle);\n        this.handle = handle;\n        this.words = iterate(words)\n            .filter(s => s.length > 0)\n            .map(s => s.toLowerCase())\n            .toSet();\n        const maxLength = iterate(this.words).map(e => e.length).reduce(Math.max);\n        const wordsByLength: string[][] = range({stop: maxLength + 1})\n            .map(() => [] as string[])\n            .toArray();\n        for (const word of this.words) {\n            wordsByLength[word.length].push(word);\n        }\n        this.rawWordsByLength = wordsByLength;\n    }\n    \n    toString(): string {\n        return `${this.name} Lexicon (${this.words.size} words)`;\n    }\n    \n    private wordsByLength(length: number): readonly string[] {\n        return this.rawWordsByLength[length] ?? [];\n    }\n    \n    hasLength(length: number): boolean {\n        return this.wordsByLength(length).length > 0;\n    }\n    \n    private maxLengthBound(): number {\n        return this.rawWordsByLength.length;\n    }\n    \n    private lengthRange(): IteratorWithOperators<number> {\n        return range({start: 1, stop: this.maxLengthBound()});\n    }\n    \n    lengths(): IteratorWithOperators<number> {\n        return this\n            .lengthRange()\n            .filter(length => this.hasLength(length));\n    }\n    \n    consecutiveLengths(): IteratorWithOperators<number> {\n        const onePastMaxLength = this\n                .lengthRange()\n                .find(length => !this.hasLength(length))\n            ?? this.maxLengthBound();\n        return range({start: 1, stop: onePastMaxLength});\n    }\n    \n    checkWord(word: string): boolean {\n        return this.words.has(word);\n    }\n    \n    checkWords(words: readonly string[]): boolean {\n        return words.every(word => this.checkWord(word));\n    }\n    \n    wordChecker(): WordChecker {\n        return {\n            word: word => this.checkWord(word),\n            words: words => this.checkWords(words),\n        };\n    }\n    \n    randomWord(length: number): string {\n        if (!this.hasLength(length)) {\n            throw new Error(`${this} has no words of length ${length}`);\n        }\n        const words = this.wordsByLength(length);\n        return words[(Math.random() * words.length) | 0];\n    }\n    \n    randomWords(size: number): IteratorWithOperators<string> {\n        return range({stop: size})\n            .map(i => this.randomWord(i + 1));\n    }\n    \n    randomShuffledWords(size: number): ShuffledWords {\n        return new ShuffledWords(this.randomWords(size).toArray());\n    }\n    \n}\n\nexport class ShuffledWords {\n    \n    private _shuffled: readonly string[];\n    \n    constructor(readonly solution: readonly string[]) {\n        this._shuffled = this.shuffle();\n    }\n    \n    get shuffled(): readonly string[] {\n        return this._shuffled;\n    }\n    \n    private doShuffle(): readonly string[] {\n        const solution = this.solution;\n        const letters = shuffledString(solution.join(\"\"));\n        const words: string[] = [];\n        let start = 0;\n        for (let i = 1; i <= solution.length; i++) {\n            const end = start + i;\n            words.push(letters.slice(start, end));\n            start = end;\n        }\n        return words;\n    }\n    \n    shuffle(): readonly string[] {\n        this._shuffled = this.doShuffle();\n        return this._shuffled;\n    }\n    \n}\n\nexport interface WordChecker {\n    \n    word(word: string): boolean;\n    \n    words(words: readonly string[]): boolean;\n    \n}\n","import iterate from \"iterare\";\nimport {IteratorWithOperators} from \"iterare/lib/iterate\";\nimport {globals} from \"./globals\";\nimport {Lexicon, LexiconMetadata, LexiconMetadataImpl, LexiconMetadataPlus} from \"./lexicon\";\nimport {lexiconIndex} from \"./lexiconIndex\";\nimport {MaybePromise} from \"./maybePromise\";\n\nexport interface LexiconHandle extends LexiconMetadataPlus {\n    getCachedPromise(): MaybePromise<Lexicon> | undefined;\n    \n    getCached(): Lexicon | undefined;\n    \n    get(): MaybePromise<Lexicon>;\n}\n\nclass LexiconHandleImpl extends LexiconMetadataImpl implements LexiconHandle {\n    \n    private lexicon: MaybePromise<Lexicon> | undefined = undefined;\n    \n    get url(): string {\n        return `${process.env.PUBLIC_URL}/lexicons/${this.name}.txt`;\n    }\n    \n    private async fetch(): Promise<Lexicon> {\n        const response = await fetch(this.url);\n        const text = await response.text();\n        if (text.startsWith(\"<!DOCTYPE html>\")) {\n            throw new Error(`the ${this} doesn't actually exist on the server`);\n        }\n        return new Lexicon(this, text.split(\"\\n\"));\n    }\n    \n    getCachedPromise(): MaybePromise<Lexicon> | undefined {\n        return this.lexicon;\n    }\n    \n    getCached(): Lexicon | undefined {\n        if (this.lexicon instanceof Promise) {\n            return;\n        }\n        return this.lexicon;\n    }\n    \n    get(): MaybePromise<Lexicon> {\n        if (this.lexicon) {\n            return this.lexicon;\n        }\n        const lexiconPromise = this.fetch();\n        this.lexicon = lexiconPromise;\n        lexiconPromise.then(lexicon => this.lexicon = lexicon);\n        return lexiconPromise;\n    }\n    \n}\n\nclass Lexicons {\n    \n    private readonly handles: Map<string, LexiconHandle>;\n    private readonly defaultNameKey: string;\n    private _defaultName: string;\n    \n    constructor(metadatas: readonly LexiconMetadata[]) {\n        this.handles = iterate(metadatas)\n            .map(metadata => [metadata.name, new LexiconHandleImpl(metadata)] as [string, LexiconHandle])\n            .toMap();\n        this.defaultNameKey = \"scramble.lexicon.default\";\n        this._defaultName = this.getDefaultName();\n        this.default().get(); // fetch immediately\n    }\n    \n    [Symbol.iterator](): IterableIterator<LexiconHandle> {\n        return this.handles.values();\n    }\n    \n    iter(): IteratorWithOperators<LexiconHandle> {\n        return iterate(this);\n    }\n    \n    private getDefaultName(): string {\n        // store default in localStorage so you resume with the previous default\n        // use localStorage since it's synchronous, so don't need to use async-await here\n        // since the data I'm storing is so small, just a name, that shouldn't be a problem at all\n        const defaultName = localStorage.getItem(this.defaultNameKey);\n        if (defaultName !== null && this.handles.has(defaultName)) {\n            return defaultName;\n        } else {\n            return this.iter().map(e => e.name).find(() => true)!;\n        }\n    }\n    \n    updateDefault(metadata: LexiconMetadata) {\n        this._defaultName = metadata.name;\n        localStorage.setItem(this.defaultNameKey, this._defaultName);\n    }\n    \n    get(name: string): LexiconHandle {\n        const handle = this.handles.get(name);\n        if (!handle) {\n            const names = this.iter().map(e => e.name);\n            throw new Error(`the Lexicon ${name} doesn't exist in {${names.join(\", \")}}`);\n        }\n        return handle;\n    }\n    \n    default(): LexiconHandle {\n        return this.get(this._defaultName);\n    }\n    \n}\n\n// see indexLexicons.mjs\nexport const lexicons = new Lexicons(lexiconIndex);\n\nglobals({lexicons});\n","export function globals(obj: object) {\n    Object.assign(globalThis, obj);\n}\n","// see indexLexicons.mjs\n\nimport {LexiconMetadata} from \"./lexicon\";\n\nexport const lexiconIndex: readonly LexiconMetadata[] = [\n    {\n        \"name\": \"American English Huge\",\n        \"size\": {\n            \"numWords\": 246744,\n            \"numChars\": 2284464,\n            \"numBytes\": 2531998\n        }\n    },\n    {\n        \"name\": \"American English Insane\",\n        \"size\": {\n            \"numWords\": 428978,\n            \"numChars\": 4120357,\n            \"numBytes\": 4550125\n        }\n    },\n    {\n        \"name\": \"American English Large\",\n        \"size\": {\n            \"numWords\": 114206,\n            \"numChars\": 1001317,\n            \"numBytes\": 1115773\n        }\n    },\n    {\n        \"name\": \"American English Small\",\n        \"size\": {\n            \"numWords\": 40106,\n            \"numChars\": 316774,\n            \"numBytes\": 356920\n        }\n    },\n    {\n        \"name\": \"American English\",\n        \"size\": {\n            \"numWords\": 63342,\n            \"numChars\": 525946,\n            \"numBytes\": 589416\n        }\n    },\n    {\n        \"name\": \"Bokmaal (Bokmål, Norsk)\",\n        \"size\": {\n            \"numWords\": 727157,\n            \"numChars\": 9343908,\n            \"numBytes\": 10071064\n        }\n    },\n    {\n        \"name\": \"Brazilian\",\n        \"size\": {\n            \"numWords\": 201214,\n            \"numChars\": 1947879,\n            \"numBytes\": 2149092\n        }\n    },\n    {\n        \"name\": \"British English Huge\",\n        \"size\": {\n            \"numWords\": 246195,\n            \"numChars\": 2281671,\n            \"numBytes\": 2528654\n        }\n    },\n    {\n        \"name\": \"British English Insane\",\n        \"size\": {\n            \"numWords\": 428462,\n            \"numChars\": 4118763,\n            \"numBytes\": 4548013\n        }\n    },\n    {\n        \"name\": \"British English Large\",\n        \"size\": {\n            \"numWords\": 113753,\n            \"numChars\": 998356,\n            \"numBytes\": 1112357\n        }\n    },\n    {\n        \"name\": \"British English Small\",\n        \"size\": {\n            \"numWords\": 39820,\n            \"numChars\": 314691,\n            \"numBytes\": 354551\n        }\n    },\n    {\n        \"name\": \"British English\",\n        \"size\": {\n            \"numWords\": 62955,\n            \"numChars\": 523025,\n            \"numBytes\": 586106\n        }\n    },\n    {\n        \"name\": \"Canadian English Huge\",\n        \"size\": {\n            \"numWords\": 246732,\n            \"numChars\": 2286330,\n            \"numBytes\": 2533852\n        }\n    },\n    {\n        \"name\": \"Canadian English Insane\",\n        \"size\": {\n            \"numWords\": 429041,\n            \"numChars\": 4123832,\n            \"numBytes\": 4553663\n        }\n    },\n    {\n        \"name\": \"Canadian English Large\",\n        \"size\": {\n            \"numWords\": 114188,\n            \"numChars\": 1002020,\n            \"numBytes\": 1116458\n        }\n    },\n    {\n        \"name\": \"Canadian English Small\",\n        \"size\": {\n            \"numWords\": 40073,\n            \"numChars\": 316754,\n            \"numBytes\": 356867\n        }\n    },\n    {\n        \"name\": \"Canadian English\",\n        \"size\": {\n            \"numWords\": 63282,\n            \"numChars\": 525737,\n            \"numBytes\": 589147\n        }\n    },\n    {\n        \"name\": \"Catala (Catalan)\",\n        \"size\": {\n            \"numWords\": 594065,\n            \"numChars\": 5988133,\n            \"numBytes\": 6784110\n        }\n    },\n    {\n        \"name\": \"Danish (Dansk)\",\n        \"size\": {\n            \"numWords\": 295965,\n            \"numChars\": 3425472,\n            \"numBytes\": 3806959\n        }\n    },\n    {\n        \"name\": \"Dutch (Nederlands)\",\n        \"size\": {\n            \"numWords\": 304745,\n            \"numChars\": 3511029,\n            \"numBytes\": 3819709\n        }\n    },\n    {\n        \"name\": \"English Sample\",\n        \"size\": {\n            \"numWords\": 15,\n            \"numChars\": 47,\n            \"numBytes\": 62\n        }\n    },\n    {\n        \"name\": \"Esperanto\",\n        \"size\": {\n            \"numWords\": 1003861,\n            \"numChars\": 11085734,\n            \"numBytes\": 12381123\n        }\n    },\n    {\n        \"name\": \"Faroese (Foeroyskt)\",\n        \"size\": {\n            \"numWords\": 153166,\n            \"numChars\": 1599931,\n            \"numBytes\": 1753096\n        }\n    },\n    {\n        \"name\": \"French\",\n        \"size\": {\n            \"numWords\": 137604,\n            \"numChars\": 1314669,\n            \"numBytes\": 1512829\n        }\n    },\n    {\n        \"name\": \"Galician Minimos (Galician)\",\n        \"size\": {\n            \"numWords\": 515124,\n            \"numChars\": 5428079,\n            \"numBytes\": 6090218\n        }\n    },\n    {\n        \"name\": \"German Medical\",\n        \"size\": {\n            \"numWords\": 6450,\n            \"numChars\": 83597,\n            \"numBytes\": 90046\n        }\n    },\n    {\n        \"name\": \"Italian\",\n        \"size\": {\n            \"numWords\": 108222,\n            \"numChars\": 1023829,\n            \"numBytes\": 1138236\n        }\n    },\n    {\n        \"name\": \"Ngerman\",\n        \"size\": {\n            \"numWords\": 236985,\n            \"numChars\": 2822682,\n            \"numBytes\": 3114239\n        }\n    },\n    {\n        \"name\": \"Nynorsk\",\n        \"size\": {\n            \"numWords\": 483403,\n            \"numChars\": 5571739,\n            \"numBytes\": 6055141\n        }\n    },\n    {\n        \"name\": \"Ogerman\",\n        \"size\": {\n            \"numWords\": 194769,\n            \"numChars\": 2289694,\n            \"numBytes\": 2531475\n        }\n    },\n    {\n        \"name\": \"Polish\",\n        \"size\": {\n            \"numWords\": 3504057,\n            \"numChars\": 43317607,\n            \"numBytes\": 49348989\n        }\n    },\n    {\n        \"name\": \"Portuguese\",\n        \"size\": {\n            \"numWords\": 427976,\n            \"numChars\": 4425761,\n            \"numBytes\": 4974519\n        }\n    },\n    {\n        \"name\": \"Spanish\",\n        \"size\": {\n            \"numWords\": 86016,\n            \"numChars\": 748671,\n            \"numBytes\": 852189\n        }\n    },\n    {\n        \"name\": \"Swedish (Svenska)\",\n        \"size\": {\n            \"numWords\": 76661,\n            \"numChars\": 720117,\n            \"numBytes\": 796777\n        }\n    },\n    {\n        \"name\": \"Swiss\",\n        \"size\": {\n            \"numWords\": 237045,\n            \"numChars\": 2828025,\n            \"numBytes\": 3115027\n        }\n    },\n    {\n        \"name\": \"Ukrainian\",\n        \"size\": {\n            \"numWords\": 1398873,\n            \"numChars\": 14791431,\n            \"numBytes\": 30981734\n        }\n    },\n    {\n        \"name\": \"Web2\",\n        \"size\": {\n            \"numWords\": 210680,\n            \"numChars\": 2038459,\n            \"numBytes\": 2249138\n        }\n    }\n];\n","import {FC, useEffect, useState} from \"react\";\nimport {default as Dropdown} from \"react-dropdown\";\nimport \"react-dropdown/style.css\";\nimport {Board, SolutionProps} from \"./board\";\nimport {Lexicon} from \"./lexicon\";\nimport {LexiconHandle, lexicons} from \"./lexicons\";\n\ninterface GameOptions {\n    lexicon: Lexicon;\n    size: number;\n}\n\nconst GameSolution: FC<SolutionProps> = ({solved, showingSolution, showSolution, numMoves, shuffle}) => {\n    return <>\n        <div>\n            {showingSolution ? \"Gave Up In \" : \"\"}{numMoves} Moves\n        </div>\n        <div>\n            {solved\n                ? (showingSolution ? \"Done!\" : \"You Won!\")\n                : <button onClick={showSolution}>Show Solution</button>}\n        </div>\n        <div>\n            <button onClick={shuffle}>Shuffle</button>\n        </div>\n    </>;\n};\n\nexport const Game: FC<GameOptions> = ({lexicon, size}) => {\n    const words = lexicon.randomShuffledWords(size);\n    return <div>\n        <Board\n            words={words}\n            wordChecker={lexicon.wordChecker()}\n            Solution={GameSolution}\n        />\n    </div>;\n};\n\ninterface StartGameOptions {\n    readonly again: boolean;\n    readonly lexiconHandle: LexiconHandle;\n    readonly size?: number;\n}\n\nconst NewGameChooser: FC<{\n    options?: GameOptions,\n    setOptions: (options: GameOptions) => void,\n}> = ({options, setOptions}) => {\n    const starting = ((): StartGameOptions => {\n        if (options) {\n            return {\n                again: true,\n                ...options,\n                lexiconHandle: options.lexicon.handle,\n            };\n        } else {\n            return {\n                again: false,\n                lexiconHandle: lexicons.default(),\n            };\n        }\n    })();\n    \n    const [lexiconHandle, setLexiconHandle] = useState(starting.lexiconHandle);\n    const [lexicon, setLexicon] = useState(starting.lexiconHandle.getCached());\n    const [size, setSize] = useState(starting.size);\n    \n    useEffect(() => {\n        // so that an old chosen size doesn't go chosen with a wrong lexicon\n        setSize(undefined);\n        \n        const newLexicon = lexiconHandle.get();\n        if (newLexicon instanceof Promise) {\n            newLexicon.then(setLexicon);\n        } else {\n            setLexicon(newLexicon);\n        }\n    }, [lexiconHandle]);\n    \n    useEffect(() => {\n        if (lexicon) {\n            lexicons.updateDefault(lexicon);\n        }\n    }, [lexicon]);\n    \n    return <div>\n        <button\n            disabled={!(lexicon && size !== undefined)}\n            onClick={() => {\n                if (lexicon && size !== undefined) {\n                    setOptions({lexicon, size});\n                } else {\n                    throw new Error(`impossible`);\n                }\n            }}>\n            {`Play${starting.again ? \" Again\" : \"\"}!`}\n        </button>\n        <br/>\n        <label>Lexicon</label>\n        <Dropdown\n            options={lexicons.iter().map(e => ({value: e.name, label: e.label()})).toArray()}\n            value={lexiconHandle.name}\n            onChange={e => setLexiconHandle(lexicons.get(e.value))}\n        />\n        {lexicon && <>\n            <label>Size</label>\n            <Dropdown\n                options={lexicon.consecutiveLengths().map(e => e.toString()).toArray()}\n                value={size?.toString()}\n                onChange={e => setSize(parseInt(e.value))}\n            />\n        </>}\n    </div>;\n};\n\nexport const Games: FC = () => {\n    const [options, setOptions] = useState<GameOptions | undefined>();\n    return <div>\n        {options && <Game lexicon={options.lexicon} size={options.size}/>}\n        <NewGameChooser options={options} setOptions={setOptions}/>\n    </div>;\n};\n","import {ReportHandler} from \"web-vitals\";\n\nexport const reportWebVitals = (onPerfEntry?: ReportHandler) => {\n    // noinspection SuspiciousTypeOfGuard\n    if (onPerfEntry && onPerfEntry instanceof Function) {\n        import(\"web-vitals\").then(({getCLS, getFID, getFCP, getLCP, getTTFB}) => {\n            getCLS(onPerfEntry);\n            getFID(onPerfEntry);\n            getFCP(onPerfEntry);\n            getLCP(onPerfEntry);\n            getTTFB(onPerfEntry);\n        });\n    }\n};\n","import {FC} from \"react\";\n\nexport const Instructions: FC = () => {\n    return <div>\n        <h1 style={{\n            textAlign: \"center\"\n        }}>\n            Scramble\n        </h1>\n        <div style={{\n            marginLeft: \"20%\",\n            marginRight: \"20%\",\n            minWidth: \"20vw\",\n        }}>\n            <h3>Instructions</h3>\n            <p>\n                Swap letters by tapping on a pair one by one\n                in an effort to make a word on each line of the board.\n            </p>\n            <p>\n                Note that you can select which lexicon (dictionary) the game will use.\n            </p>\n            <p>\n                And don't forget to select the size of your board to start.\n            </p>\n        </div>\n    </div>;\n};\n","import {FC} from \"react\";\nimport {Games} from \"./game\";\nimport {Instructions} from \"./instructions\";\n\nexport const Scramble: FC = () => {\n    return <div>\n        <div style={{\n            textAlign: \"center\",\n        }}>\n            <Games/>\n        </div>\n        <Instructions/>\n    </div>;\n};\n","import {FC} from \"react\";\nimport \"./App.css\";\nimport {Scramble} from \"./main/scramble\";\n\nexport const App: FC = () => {\n    return <Scramble/>;\n};\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {App} from \"./App\";\nimport \"./index.css\";\nimport {reportWebVitals} from \"./reportWebVitals\";\n\nReactDOM.render(\n    <React.StrictMode>\n        <App/>\n    </React.StrictMode>,\n    document.querySelector(\"#root\"),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}