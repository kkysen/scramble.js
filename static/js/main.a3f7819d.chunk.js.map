{"version":3,"sources":["main/board.tsx","main/range.ts","main/shuffle.ts","main/lexicon.ts","main/lexicons.ts","main/globals.ts","main/lexiconIndex.ts","main/game.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Letter","letter","selected","setSelected","isWord","boardSize","size","a","scale","n","onClick","style","backgroundColor","padding","margin","width","fontSize","borderWidth","borderStyle","borderRadius","textAlign","Word","word","selectedIndex","setSelectedIndex","display","justifyContent","alignItems","alignContent","fontWeight","toUpperCase","map","i","Board","words","solution","shuffled","check","wordChecker","Solution","initState","useCallback","isFirst","x","y","solved","numMoves","useState","setState","showingSolution","useEffect","console","log","join","j","splitWords","temp","newWords","setIJ","length","showSolution","range_iter","start","stop","step","range","iterate","shuffle","Math","floor","random","LexiconMetadataImpl","metadata","this","name","numWords","fileSize","numBytes","Lexicon","handle","rawWordsByLength","filter","s","toLowerCase","toSet","wordsByLength","e","reduce","max","toArray","push","maxLengthBound","lengthRange","hasLength","find","has","every","checkWord","checkWords","Error","randomWord","randomWords","letters","shuffledString","end","slice","LexiconHandleImpl","lexicon","undefined","fetch","url","response","text","startsWith","split","Promise","lexiconPromise","then","process","Symbol","iterator","obj","lexicons","metadatas","handles","defaultNameKey","_defaultName","toMap","getDefaultName","default","get","values","defaultName","localStorage","getItem","iter","setItem","names","Object","assign","globalThis","GameSolution","Game","randomShuffledWords","NewGameChooser","options","setOptions","starting","again","lexiconHandle","setLexiconHandle","getCached","setLexicon","setSize","newLexicon","updateDefault","disabled","value","label","onChange","consecutiveLengths","toString","parseInt","Games","App","className","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a3f7819d.chunk.js","sourcesContent":["import {FC, useCallback, useEffect, useState} from \"react\";\nimport {ShuffledWords, WordChecker} from \"./lexicon\";\n\nconst Letter: FC<{\n    letter: string;\n    selected: boolean;\n    setSelected: () => void;\n    isWord: boolean;\n    boardSize: number;\n}> = ({letter, selected, setSelected, isWord, boardSize}) => {\n    const size = ((): (n: number) => number => {\n        // we want to pin these two scales and adjust in-between\n        // use point-slope form to calculate scale\n        interface Point {\n            readonly boardSize: number;\n            readonly scale: number;\n        }\n        \n        const a: Point = {boardSize: 5, scale: 1};\n        const b: Point = {boardSize: 25, scale: 2};\n        const slope = (a.scale - b.scale) / (a.boardSize - b.boardSize);\n        const scale = slope * (boardSize - a.boardSize) + a.scale;\n        return n => (n / scale) * 1.5;\n    })();\n    \n    return <div\n        onClick={setSelected}\n        style={{\n            backgroundColor: selected ? \"yellow\" : \"white\",\n            padding: `${size(1)}%`,\n            margin: `${size(0.2)}%`,\n            width: `${size(3)}%`,\n            fontSize: `${size(3)}vw`,\n            borderWidth: `${size(1)}vw`,\n            borderStyle: selected ? \"inset\" : \"outset\",\n            borderRadius: isWord ? `${size(2)}vw` : 0,\n            textAlign: \"center\",\n        }}\n    >\n        {letter}\n    </div>;\n};\n\nconst Word: FC<{\n    word: string;\n    isWord: boolean;\n    selectedIndex: number;\n    setSelectedIndex: (index: number) => void;\n    boardSize: number;\n}> = ({word, isWord, selectedIndex, setSelectedIndex, boardSize}) => {\n    return <div style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        alignContent: \"center\",\n        fontWeight: isWord ? \"bold\" : \"normal\",\n    }}>\n        {[...word.toUpperCase()].map((letter, i) => <Letter\n            key={i}\n            letter={letter}\n            selected={selectedIndex === i}\n            setSelected={() => setSelectedIndex(i)}\n            isWord={isWord}\n            boardSize={boardSize}\n        />)}\n    </div>;\n};\n\nexport interface SolutionProps {\n    solved: boolean;\n    showingSolution: boolean;\n    showSolution: () => void;\n    numMoves: number;\n}\n\nexport const Board: FC<{\n    words: ShuffledWords;\n    wordChecker: WordChecker;\n    Solution: FC<SolutionProps>;\n}> = ({words: {solution, shuffled}, wordChecker: check, Solution}) => {\n    const initState = useCallback((isFirst: boolean) => {\n        return {isFirst, x: -1, y: -1, words: shuffled, solved: check.words(shuffled), numMoves: 0};\n    }, [check, shuffled]);\n    \n    const [{isFirst, x, y, words, solved, numMoves}, setState] = useState(initState(true));\n    const showingSolution = words === solution;\n    \n    useEffect(() => {\n        console.log(solution.join(\"\\n\"));\n        if (!isFirst) {\n            setState(initState(false));\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [initState]);\n    \n    function setIJ(i: number, j: number) {\n        if (y === -1 || x === -1) {\n            // no letters clicked on yet\n            setState({isFirst: false, x: i, y: j, words, solved, numMoves});\n        } else if (x === i && y === j) {\n            // clicked on same letter twice\n            setState({isFirst: false, x: -1, y: -1, words, solved, numMoves});\n        } else {\n            // one letter clicked on, so swap them now\n            const splitWords = words.map(word => [...word]);\n            const temp = splitWords[i][j];\n            splitWords[i][j] = splitWords[x][y];\n            splitWords[x][y] = temp;\n            const newWords = splitWords.map(word => word.join(\"\"));\n            setState({\n                isFirst: false,\n                x: -1,\n                y: -1,\n                words: newWords,\n                solved: check.words(newWords),\n                numMoves: numMoves + 1,\n            });\n        }\n    }\n    \n    return <>\n        <div>\n            {words.map((word, i) => <Word\n                key={i}\n                word={word}\n                isWord={check.word(word)}\n                selectedIndex={i === x ? y : -1}\n                setSelectedIndex={j => setIJ(i, j)}\n                boardSize={words.length}\n            />)}\n        </div>\n        <Solution\n            solved={solved}\n            showingSolution={showingSolution}\n            showSolution={() => setState({\n                isFirst: false,\n                x: -1,\n                y: -1,\n                words: solution,\n                solved: true,\n                numMoves,\n            })}\n            numMoves={numMoves}\n        />\n    </>;\n};\n","import iterate from \"iterare\";\nimport {IteratorWithOperators} from \"iterare/lib/iterate\";\n\nexport interface Range {\n    start?: number;\n    stop: number;\n    step?: number;\n}\n\nfunction* range_iter({start = 0, stop, step = 1}: Range) {\n    while (start < stop) {\n        yield start;\n        start += step;\n    }\n}\n\nexport function range(range: Range): IteratorWithOperators<number> {\n    return iterate(range_iter(range));\n}\n","export function shuffle<T>(a: T[]) {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * i);\n        const temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n}\n\nexport function shuffled<T>(a: readonly T[]): T[] {\n    const b = [...a];\n    shuffle(b);\n    return b;\n}\n\nexport function shuffledString(s: string): string {\n    const a = [...s];\n    shuffle(a);\n    return a.join(\"\");\n}\n","import fileSize from \"filesize\";\nimport iterate from \"iterare\";\nimport {IteratorWithOperators} from \"iterare/lib/iterate\";\nimport {LexiconHandle} from \"./lexicons\";\nimport {range} from \"./range\";\nimport {shuffledString} from \"./shuffle\";\n\nexport interface LexiconSize {\n    readonly numWords: number;\n    readonly numChars: number;\n    readonly numBytes: number;\n}\n\nexport interface LexiconMetadata {\n    readonly name: string;\n    readonly size: LexiconSize;\n}\n\nexport interface LexiconMetadataPlus extends LexiconMetadata {\n    toString(): string;\n    label(): string;\n}\n\nexport class LexiconMetadataImpl implements LexiconMetadataPlus {\n    \n    constructor(protected metadata: LexiconMetadata) {}\n    \n    get name(): string {\n        return this.metadata.name;\n    }\n    \n    get size(): LexiconSize {\n        return this.metadata.size;\n    }\n    \n    toString(): string {\n        return `Lexicon \"${this.name}\"`;\n    }\n    \n    label(): string {\n        return `${this.name} (${this.size.numWords} words, ${fileSize(this.size.numBytes)})`;\n    }\n    \n}\n\nexport class Lexicon extends LexiconMetadataImpl {\n    readonly handle: LexiconHandle;\n    private readonly words: ReadonlySet<string>;\n    private readonly rawWordsByLength: readonly ReadonlyArray<string>[];\n    \n    constructor(handle: LexiconHandle, words: Iterable<string>) {\n        super(handle);\n        this.handle = handle;\n        this.words = iterate(words)\n            .filter(s => s.length > 0)\n            .map(s => s.toLowerCase())\n            .toSet();\n        const maxLength = iterate(this.words).map(e => e.length).reduce(Math.max);\n        const wordsByLength: string[][] = range({stop: maxLength + 1})\n            .map(() => [] as string[])\n            .toArray();\n        for (const word of this.words) {\n            wordsByLength[word.length].push(word);\n        }\n        this.rawWordsByLength = wordsByLength;\n    }\n    \n    toString(): string {\n        return `${this.name} Lexicon (${this.words.size} words)`;\n    }\n    \n    private wordsByLength(length: number): readonly string[] {\n        return this.rawWordsByLength[length] ?? [];\n    }\n    \n    hasLength(length: number): boolean {\n        return this.wordsByLength(length).length > 0;\n    }\n    \n    private maxLengthBound(): number {\n        return this.rawWordsByLength.length;\n    }\n    \n    private lengthRange(): IteratorWithOperators<number> {\n        return range({start: 1, stop: this.maxLengthBound()});\n    }\n    \n    lengths(): IteratorWithOperators<number> {\n        return this\n            .lengthRange()\n            .filter(length => this.hasLength(length));\n    }\n    \n    consecutiveLengths(): IteratorWithOperators<number> {\n        const onePastMaxLength = this\n                .lengthRange()\n                .find(length => !this.hasLength(length))\n            ?? this.maxLengthBound();\n        return range({start: 1, stop: onePastMaxLength});\n    }\n    \n    checkWord(word: string): boolean {\n        return this.words.has(word);\n    }\n    \n    checkWords(words: readonly string[]): boolean {\n        return words.every(word => this.checkWord(word));\n    }\n    \n    wordChecker(): WordChecker {\n        return {\n            word: word => this.checkWord(word),\n            words: words => this.checkWords(words),\n        };\n    }\n    \n    randomWord(length: number): string {\n        if (!this.hasLength(length)) {\n            throw new Error(`${this} has no words of length ${length}`);\n        }\n        const words = this.wordsByLength(length);\n        return words[(Math.random() * words.length) | 0];\n    }\n    \n    randomWords(size: number): IteratorWithOperators<string> {\n        return range({stop: size})\n            .map(i => this.randomWord(i + 1));\n    }\n    \n    randomShuffledWords(size: number): ShuffledWords {\n        const solution = this.randomWords(size).toArray();\n        const letters = shuffledString(solution.join(\"\"));\n        const words: string[] = [];\n        let start = 0;\n        for (let i = 1; i <= size; i++) {\n            const end = start + i;\n            words.push(letters.slice(start, end));\n            start = end;\n        }\n        return {solution, shuffled: words};\n    }\n    \n}\n\nexport interface ShuffledWords {\n    readonly solution: readonly string[];\n    readonly shuffled: readonly string[];\n}\n\nexport interface WordChecker {\n    \n    word(word: string): boolean;\n    \n    words(words: readonly string[]): boolean;\n    \n}\n","import iterate from \"iterare\";\nimport {IteratorWithOperators} from \"iterare/lib/iterate\";\nimport {globals} from \"./globals\";\nimport {Lexicon, LexiconMetadata, LexiconMetadataImpl, LexiconMetadataPlus} from \"./lexicon\";\nimport {lexiconIndex} from \"./lexiconIndex\";\nimport {MaybePromise} from \"./maybePromise\";\n\nexport interface LexiconHandle extends LexiconMetadataPlus {\n    getCachedPromise(): MaybePromise<Lexicon> | undefined;\n    \n    getCached(): Lexicon | undefined;\n    \n    get(): MaybePromise<Lexicon>;\n}\n\nclass LexiconHandleImpl extends LexiconMetadataImpl implements LexiconHandle {\n    \n    private lexicon: MaybePromise<Lexicon> | undefined = undefined;\n    \n    get url(): string {\n        return `${process.env.PUBLIC_URL}/lexicons/${this.name}.txt`;\n    }\n    \n    private async fetch(): Promise<Lexicon> {\n        const response = await fetch(this.url);\n        const text = await response.text();\n        if (text.startsWith(\"<!DOCTYPE html>\")) {\n            throw new Error(`the ${this} doesn't actually exist on the server`);\n        }\n        return new Lexicon(this, text.split(\"\\n\"));\n    }\n    \n    getCachedPromise(): MaybePromise<Lexicon> | undefined {\n        return this.lexicon;\n    }\n    \n    getCached(): Lexicon | undefined {\n        if (this.lexicon instanceof Promise) {\n            return;\n        }\n        return this.lexicon;\n    }\n    \n    get(): MaybePromise<Lexicon> {\n        if (this.lexicon) {\n            return this.lexicon;\n        }\n        const lexiconPromise = this.fetch();\n        this.lexicon = lexiconPromise;\n        lexiconPromise.then(lexicon => this.lexicon = lexicon);\n        return lexiconPromise;\n    }\n    \n}\n\nclass Lexicons {\n    \n    private readonly handles: Map<string, LexiconHandle>;\n    private readonly defaultNameKey: string;\n    private _defaultName: string;\n    \n    constructor(metadatas: readonly LexiconMetadata[]) {\n        this.handles = iterate(metadatas)\n            .map(metadata => [metadata.name, new LexiconHandleImpl(metadata)] as [string, LexiconHandle])\n            .toMap();\n        this.defaultNameKey = \"scramble.lexicon.default\";\n        this._defaultName = this.getDefaultName();\n        this.default().get(); // fetch immediately\n    }\n    \n    [Symbol.iterator](): IterableIterator<LexiconHandle> {\n        return this.handles.values();\n    }\n    \n    iter(): IteratorWithOperators<LexiconHandle> {\n        return iterate(this);\n    }\n    \n    private getDefaultName(): string {\n        // store default in localStorage so you resume with the previous default\n        // use localStorage since it's synchronous, so don't need to use async-await here\n        // since the data I'm storing is so small, just a name, that shouldn't be a problem at all\n        const defaultName = localStorage.getItem(this.defaultNameKey);\n        if (defaultName !== null && this.handles.has(defaultName)) {\n            return defaultName;\n        } else {\n            return this.iter().map(e => e.name).find(() => true)!;\n        }\n    }\n    \n    updateDefault(metadata: LexiconMetadata) {\n        this._defaultName = metadata.name;\n        localStorage.setItem(this.defaultNameKey, this._defaultName);\n    }\n    \n    get(name: string): LexiconHandle {\n        const handle = this.handles.get(name);\n        if (!handle) {\n            const names = this.iter().map(e => e.name);\n            throw new Error(`the Lexicon ${name} doesn't exist in {${names.join(\", \")}}`);\n        }\n        return handle;\n    }\n    \n    default(): LexiconHandle {\n        return this.get(this._defaultName);\n    }\n    \n}\n\n// see indexLexicons.mjs\nexport const lexicons = new Lexicons(lexiconIndex);\n\nglobals({lexicons});\n","export function globals(obj: object) {\n    Object.assign(globalThis, obj);\n}\n","// see indexLexicons.mjs\n\nimport {LexiconMetadata} from \"./lexicon\";\n\nexport const lexiconIndex: readonly LexiconMetadata[] = [\n    {\n        \"name\": \"American English Huge\",\n        \"size\": {\n            \"numWords\": 246744,\n            \"numChars\": 2284464,\n            \"numBytes\": 2531998\n        }\n    },\n    {\n        \"name\": \"American English Insane\",\n        \"size\": {\n            \"numWords\": 428978,\n            \"numChars\": 4120357,\n            \"numBytes\": 4550125\n        }\n    },\n    {\n        \"name\": \"American English Large\",\n        \"size\": {\n            \"numWords\": 114206,\n            \"numChars\": 1001317,\n            \"numBytes\": 1115773\n        }\n    },\n    {\n        \"name\": \"American English Small\",\n        \"size\": {\n            \"numWords\": 40106,\n            \"numChars\": 316774,\n            \"numBytes\": 356920\n        }\n    },\n    {\n        \"name\": \"American English\",\n        \"size\": {\n            \"numWords\": 63342,\n            \"numChars\": 525946,\n            \"numBytes\": 589416\n        }\n    },\n    {\n        \"name\": \"Bokmaal (Bokmål, Norsk)\",\n        \"size\": {\n            \"numWords\": 727157,\n            \"numChars\": 9343908,\n            \"numBytes\": 10071064\n        }\n    },\n    {\n        \"name\": \"Brazilian\",\n        \"size\": {\n            \"numWords\": 201214,\n            \"numChars\": 1947879,\n            \"numBytes\": 2149092\n        }\n    },\n    {\n        \"name\": \"British English\",\n        \"size\": {\n            \"numWords\": 62955,\n            \"numChars\": 523025,\n            \"numBytes\": 586106\n        }\n    },\n    {\n        \"name\": \"Canadian English\",\n        \"size\": {\n            \"numWords\": 63282,\n            \"numChars\": 525737,\n            \"numBytes\": 589147\n        }\n    },\n    {\n        \"name\": \"Catala (Catalan)\",\n        \"size\": {\n            \"numWords\": 594065,\n            \"numChars\": 5988133,\n            \"numBytes\": 6784110\n        }\n    },\n    {\n        \"name\": \"Dutch (Nederlands)\",\n        \"size\": {\n            \"numWords\": 304745,\n            \"numChars\": 3511029,\n            \"numBytes\": 3819709\n        }\n    },\n    {\n        \"name\": \"English Sample\",\n        \"size\": {\n            \"numWords\": 15,\n            \"numChars\": 47,\n            \"numBytes\": 62\n        }\n    },\n    {\n        \"name\": \"Esperanto\",\n        \"size\": {\n            \"numWords\": 1003861,\n            \"numChars\": 11085734,\n            \"numBytes\": 12381123\n        }\n    },\n    {\n        \"name\": \"French\",\n        \"size\": {\n            \"numWords\": 137604,\n            \"numChars\": 1314669,\n            \"numBytes\": 1512829\n        }\n    },\n    {\n        \"name\": \"Italian\",\n        \"size\": {\n            \"numWords\": 108222,\n            \"numChars\": 1023829,\n            \"numBytes\": 1138236\n        }\n    },\n    {\n        \"name\": \"Ngerman\",\n        \"size\": {\n            \"numWords\": 236985,\n            \"numChars\": 2822682,\n            \"numBytes\": 3114239\n        }\n    },\n    {\n        \"name\": \"Nynorsk\",\n        \"size\": {\n            \"numWords\": 483403,\n            \"numChars\": 5571739,\n            \"numBytes\": 6055141\n        }\n    },\n    {\n        \"name\": \"Polish\",\n        \"size\": {\n            \"numWords\": 3504057,\n            \"numChars\": 43317607,\n            \"numBytes\": 49348989\n        }\n    },\n    {\n        \"name\": \"Portuguese\",\n        \"size\": {\n            \"numWords\": 427976,\n            \"numChars\": 4425761,\n            \"numBytes\": 4974519\n        }\n    },\n    {\n        \"name\": \"Spanish\",\n        \"size\": {\n            \"numWords\": 86016,\n            \"numChars\": 748671,\n            \"numBytes\": 852189\n        }\n    },\n    {\n        \"name\": \"Swedish (Svenska)\",\n        \"size\": {\n            \"numWords\": 76661,\n            \"numChars\": 720117,\n            \"numBytes\": 796777\n        }\n    },\n    {\n        \"name\": \"Ukrainian\",\n        \"size\": {\n            \"numWords\": 1398873,\n            \"numChars\": 14791431,\n            \"numBytes\": 30981734\n        }\n    }\n];\n","import {FC, useEffect, useState} from \"react\";\nimport {default as Dropdown} from \"react-dropdown\";\nimport \"react-dropdown/style.css\";\nimport {Board, SolutionProps} from \"./board\";\nimport {Lexicon} from \"./lexicon\";\nimport {LexiconHandle, lexicons} from \"./lexicons\";\n\ninterface GameOptions {\n    lexicon: Lexicon;\n    size: number;\n}\n\nconst GameSolution: FC<SolutionProps> = ({solved, showingSolution, showSolution, numMoves}) => {\n    return <>\n        <div>{showingSolution ? \"Gave Up In \" : \"\"}{numMoves} Moves</div>\n        <div>{solved ? (showingSolution ? \"Done!\" : \"You Won!\") : <button onClick={showSolution}>Show Solution</button>}</div>\n    </>;\n};\n\nexport const Game: FC<GameOptions> = ({lexicon, size}) => {\n    const words = lexicon.randomShuffledWords(size);\n    return <div>\n        <Board\n            words={words}\n            wordChecker={lexicon.wordChecker()}\n            Solution={GameSolution}\n        />\n    </div>;\n};\n\ninterface StartGameOptions {\n    readonly again: boolean;\n    readonly lexiconHandle: LexiconHandle;\n    readonly size?: number;\n}\n\nconst NewGameChooser: FC<{\n    options?: GameOptions,\n    setOptions: (options: GameOptions) => void,\n}> = ({options, setOptions}) => {\n    const starting = ((): StartGameOptions => {\n        if (options) {\n            return {\n                again: true,\n                ...options,\n                lexiconHandle: options.lexicon.handle,\n            };\n        } else {\n            return {\n                again: false,\n                lexiconHandle: lexicons.default(),\n            };\n        }\n    })();\n    \n    const [lexiconHandle, setLexiconHandle] = useState(starting.lexiconHandle);\n    const [lexicon, setLexicon] = useState(starting.lexiconHandle.getCached());\n    const [size, setSize] = useState(starting.size);\n    \n    useEffect(() => {\n        // so that an old chosen size doesn't go chosen with a wrong lexicon\n        setSize(undefined);\n        \n        const newLexicon = lexiconHandle.get();\n        if (newLexicon instanceof Promise) {\n            newLexicon.then(setLexicon);\n        } else {\n            setLexicon(newLexicon);\n        }\n    }, [lexiconHandle]);\n    \n    useEffect(() => {\n        if (lexicon) {\n            lexicons.updateDefault(lexicon);\n        }\n    }, [lexicon]);\n    \n    return <div>\n        <button\n            disabled={!(lexicon && size !== undefined)}\n            onClick={() => {\n                if (lexicon && size !== undefined) {\n                    setOptions({lexicon, size});\n                } else {\n                    throw new Error(`impossible`);\n                }\n            }}>\n            {`Play${starting.again ? \" Again\" : \"\"}!`}\n        </button>\n        <br/>\n        <label>Lexicon</label>\n        <Dropdown\n            options={lexicons.iter().map(e => ({value: e.name, label: e.label()})).toArray()}\n            value={lexiconHandle.name}\n            onChange={e => setLexiconHandle(lexicons.get(e.value))}\n        />\n        {lexicon && <>\n            <label>Size</label>\n            <Dropdown\n                options={lexicon.consecutiveLengths().map(e => e.toString()).toArray()}\n                value={size?.toString()}\n                onChange={e => setSize(parseInt(e.value))}\n            />\n        </>}\n    </div>;\n};\n\nexport const Games: FC = () => {\n    const [options, setOptions] = useState<GameOptions | undefined>();\n    return <div>\n        {options && <Game lexicon={options.lexicon} size={options.size}/>}\n        <NewGameChooser options={options} setOptions={setOptions}/>\n    </div>;\n};\n","import \"./App.css\";\nimport {Games} from \"./main/game\";\n\nfunction App() {\n    return <div className=\"App\">\n        <Games/>\n    </div>;\n}\n\nexport default App;\n","import {ReportHandler} from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n    if (onPerfEntry && onPerfEntry instanceof Function) {\n        import(\"web-vitals\").then(({getCLS, getFID, getFCP, getLCP, getTTFB}) => {\n            getCLS(onPerfEntry);\n            getFID(onPerfEntry);\n            getFCP(onPerfEntry);\n            getLCP(onPerfEntry);\n            getTTFB(onPerfEntry);\n        });\n    }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"./index.css\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n    <React.StrictMode>\n        <App/>\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}